<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>QMF Tech</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
        #output, #deploymentOutput {
            margin-top: 20px;
        }
        pre {
            background: #f4f4f4;
            padding: 10px;
            border: 1px solid #ddd;
            overflow-x: auto;
        }
        #dropZone {
            border: 2px dashed #bbb;
            border-radius: 5px;
            padding: 20px;
            text-align: center;
            color: #bbb;
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <h1>QMF Tech Token Airdrop Administrator</h1>

    <button id="connectButton">Conectar a MetaMask</button>
    <p id="account"></p>

    <div id="airdropSection" style="display:none;">
        <div id="dropZone">Arrastra el archivo aquí</div>
        <button id="createAirdropButton" style="display:none;">Crear Airdrop</button>
        <div id="deploymentOutput"></div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.5.2/web3.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/crypto-js/4.1.1/crypto-js.min.js"></script>
    <script>
        let account = "";
        let merkleRoot = "";
        let addresses = [];

        document.getElementById('connectButton').addEventListener('click', connectMetaMask);
        document.getElementById('createAirdropButton').addEventListener('click', async () => {
            if (merkleRoot) {
                await callAddMerkleRootFunction(merkleRoot);
            }
        });

        async function connectMetaMask() {
            if (typeof window.ethereum !== 'undefined') {
                try {
                    const accounts = await ethereum.request({ method: 'eth_requestAccounts' });
                    account = accounts[0];
                    document.getElementById('account').innerText = `Conectado: ${account}`;
                    document.getElementById('airdropSection').style.display = 'block';
                } catch (error) {
                    console.error(error);
                }
            } else {
                alert('MetaMask no está instalado.');
            }
        }

        const dropZone = document.getElementById('dropZone');
        dropZone.addEventListener('dragover', (e) => {
            e.preventDefault();
            dropZone.style.backgroundColor = '#f0f0f0';
        });

        dropZone.addEventListener('dragleave', () => {
            dropZone.style.backgroundColor = '#fff';
        });

        dropZone.addEventListener('drop', (e) => {
            e.preventDefault();
            dropZone.style.backgroundColor = '#fff';
            const file = e.dataTransfer.files[0];
            handleFile(file);
        });

        function handleFile(file) {
            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                addresses = text.split(/\r?\n/).filter(line => line.trim() !== '');
                if (addresses.length === 0) {
                    document.getElementById('deploymentOutput').innerText = 'El archivo CSV está vacío o no contiene direcciones válidas.';
                    return;
                }
                merkleRoot = createMerkleTree(addresses);
                document.getElementById('deploymentOutput').innerHTML = `<h2>Raíz del Árbol de Merkle:</h2><pre>${merkleRoot}</pre>`;
                document.getElementById('createAirdropButton').style.display = 'block';
            };
            reader.readAsText(file);
        }

        function createMerkleTree(leaves) {
            let hashedLeaves = leaves.map(leaf => hash(leaf));
            while (hashedLeaves.length > 1) {
                if (hashedLeaves.length % 2 !== 0) {
                    hashedLeaves.push(hashedLeaves[hashedLeaves.length - 1]);
                }
                const newLevel = [];
                for (let i = 0; i < hashedLeaves.length; i += 2) {
                    newLevel.push(hash(hashedLeaves[i] + hashedLeaves[i + 1]));
                }
                hashedLeaves = newLevel;
            }
            return hashedLeaves[0];
        }

        function hash(data) {
            return CryptoJS.SHA256(data).toString(CryptoJS.enc.Hex);
        }

        async function callAddMerkleRootFunction(merkleRoot) {
            const abi = [
                // ABI del contrato AirdropQMF.sol
            ];
            const contractAddress = '0x...'; // Dirección del contrato AirdropQMF.sol

            const web3 = new Web3(window.ethereum);
            const airdropContract = new web3.eth.Contract(abi, contractAddress);

            try {
                await airdropContract.methods.addMerkleRoot(merkleRoot).send({
                    from: account,
                    gas: 1500000,
                    gasPrice: '30000000000'
                });
                document.getElementById('deploymentOutput').innerText = 'Merkle root añadida exitosamente al contrato.';
            } catch (error) {
                document.getElementById('deploymentOutput').innerText = `Error al añadir la merkle root: ${error.message}`;
            }
        }
    </script>
</body>
</html>
